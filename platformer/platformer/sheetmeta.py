"""Utilities for describing and loading spritesheet metadata.

The runtime previously consumed the raw JSON generated by
``make_bytebuddy_assets.py``.  The JSON used integer strings as dictionary
keys which made manual editing cumbersome.  This module provides a couple of
small dataclasses that describe the spritesheet metadata in a Python friendly
way and helpers for producing/consuming JSON payloads that mirror those data
structures.

The JSON payloads follow a tiny schema tailored for the game and intended to
be edited by hand:

.. code-block:: json

   {
     "tile": 16,
     "padding": 1,
     "cols": 8,
     "frames": [
       {"x": 1, "y": 1, "w": 16, "h": 16},
       {"x": 18, "y": 1, "w": 16, "h": 16}
     ],
     "anims": {
       "idle": {"start": 0, "count": 1},
       "run": {"start": 1, "count": 6}
     }
   }

``frames`` lists every crop rectangle in spritesheet order, and ``anims``
maps animation names to contiguous frame ranges.  The structure deliberately
mirrors :class:`SpriteSheetMeta` rather than a broader industry standard (no
single JSON format is ubiquitous) so that it remains lightweight and easy for
students to understand and tweak.
"""
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Mapping, MutableMapping
import json

import pygame


@dataclass(slots=True)
class FrameSpec:
    """Pixel bounds of a frame inside a spritesheet."""

    x: int
    y: int
    w: int
    h: int

    @classmethod
    def from_box(cls, box: Iterable[int]) -> "FrameSpec":
        x0, y0, x1, y1 = box
        return cls(x=int(x0), y=int(y0), w=int(x1 - x0), h=int(y1 - y0))

    @classmethod
    def from_mapping(cls, data: Mapping[str, int]) -> "FrameSpec":
        return cls(x=int(data["x"]), y=int(data["y"]), w=int(data["w"]), h=int(data["h"]))

    def to_mapping(self) -> Dict[str, int]:
        return {"x": self.x, "y": self.y, "w": self.w, "h": self.h}

    def to_rect(self) -> pygame.Rect:
        return pygame.Rect(self.x, self.y, self.w, self.h)


@dataclass(slots=True)
class AnimationSpec:
    """Start/count pair describing a contiguous animation sequence."""

    start: int
    count: int

    @classmethod
    def from_mapping(cls, data: Mapping[str, int]) -> "AnimationSpec":
        return cls(start=int(data["start"]), count=int(data["count"]))

    def to_mapping(self) -> Dict[str, int]:
        return {"start": self.start, "count": self.count}


@dataclass
class SpriteSheetMeta:
    """Structured view of the spritesheet metadata JSON."""

    tile: int
    padding: int
    cols: int
    frames: List[FrameSpec]
    animations: Dict[str, AnimationSpec]

    @classmethod
    def from_mapping(cls, data: Mapping[str, object]) -> "SpriteSheetMeta":
        frames_raw = data.get("frames", [])
        if isinstance(frames_raw, Mapping):
            # Legacy format: dictionary keyed by integer strings
            ordered = [frames_raw[k] for k in sorted(frames_raw, key=lambda s: int(s))]
        else:
            ordered = list(frames_raw)
        frames = [FrameSpec.from_mapping(frame) for frame in ordered]

        anims_raw = data.get("anims", {})
        animations = {name: AnimationSpec.from_mapping(spec) for name, spec in anims_raw.items()}

        tile = int(data.get("tile", 0))
        padding = int(data.get("padding", 0))
        cols = int(data.get("cols", 0))
        return cls(tile=tile, padding=padding, cols=cols, frames=frames, animations=animations)

    @classmethod
    def load(cls, path: Path | str) -> "SpriteSheetMeta":
        with open(path, "r") as f:
            data = json.load(f)
        return cls.from_mapping(data)

    def dump(self, path: Path | str) -> None:
        with open(path, "w") as f:
            json.dump(self.to_mapping(), f, indent=2)

    def to_mapping(self) -> MutableMapping[str, object]:
        return {
            "tile": self.tile,
            "padding": self.padding,
            "cols": self.cols,
            "frames": [frame.to_mapping() for frame in self.frames],
            "anims": {name: anim.to_mapping() for name, anim in self.animations.items()},
        }

    # Convenience helpers -------------------------------------------------

    def frame_rect(self, index: int) -> pygame.Rect:
        return self.frames[index].to_rect()

    def frame_slice(self, index: int) -> FrameSpec:
        return self.frames[index]

    def animation_indices(self, name: str) -> range:
        spec = self.animations[name]
        return range(spec.start, spec.start + spec.count)

    def copy(self) -> "SpriteSheetMeta":
        return SpriteSheetMeta(
            tile=self.tile,
            padding=self.padding,
            cols=self.cols,
            frames=[FrameSpec(frame.x, frame.y, frame.w, frame.h) for frame in self.frames],
            animations={name: AnimationSpec(anim.start, anim.count) for name, anim in self.animations.items()},
        )

    def scaled(self, scale: int) -> "SpriteSheetMeta":
        if scale == 1:
            return self.copy()
        scaled_frames = [
            FrameSpec(frame.x * scale, frame.y * scale, frame.w * scale, frame.h * scale)
            for frame in self.frames
        ]
        return SpriteSheetMeta(
            tile=self.tile * scale,
            padding=self.padding * scale,
            cols=self.cols,
            frames=scaled_frames,
            animations={name: AnimationSpec(anim.start, anim.count) for name, anim in self.animations.items()},
        )


class SpriteSheetMetaBuilder:
    """Helper for constructing ``SpriteSheetMeta`` objects programmatically."""

    def __init__(self, *, tile: int, padding: int, cols: int):
        self.tile = tile
        self.padding = padding
        self.cols = cols
        self.frames: List[FrameSpec] = []
        self.animations: Dict[str, AnimationSpec] = {}

    def grid_box(self, row: int, col: int, *, tile: int | None = None, padding: int | None = None) -> tuple[int, int, int, int]:
        tile = tile if tile is not None else self.tile
        padding = padding if padding is not None else self.padding
        x = padding + col * (tile + padding)
        y = padding + row * (tile + padding)
        return (x, y, x + tile, y + tile)

    def add_frame(self, box: Iterable[int]) -> int:
        frame = FrameSpec.from_box(box)
        self.frames.append(frame)
        return len(self.frames) - 1

    def add_animation(self, name: str, boxes: Iterable[Iterable[int]]) -> None:
        start = len(self.frames)
        for box in boxes:
            self.add_frame(box)
        count = len(self.frames) - start
        self.animations[name] = AnimationSpec(start=start, count=count)

    def build(self) -> SpriteSheetMeta:
        return SpriteSheetMeta(
            tile=self.tile,
            padding=self.padding,
            cols=self.cols,
            frames=list(self.frames),
            animations=dict(self.animations),
        )
